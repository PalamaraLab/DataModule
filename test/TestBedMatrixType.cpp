// This file is part of https://github.com/PalamaraLab/DataModule which is released under the GPL-3.0 license.
// See accompanying LICENSE and COPYING for copyright notice and full details.

#include "BedMatrixType.hpp"

#include <catch2/catch.hpp>

#include <cstdint>
#include <string>

#include <fmt/core.h>
#include <fmt/ostream.h>
#include <fmt/ranges.h>

namespace asmc {

TEST_CASE("BedMatrixType: test (small) real example", "[BedMatrixType]") {

  // Simulated data generated by plink, with fraction 0.05 missing data, 50 individuals, 100 SNPs
  std::string bedFile = DATA_MODULE_TEST_DIR "/data/bedbimfam/real_example.bed";
  std::string bimFile = DATA_MODULE_TEST_DIR "/data/bedbimfam/real_example.bim";
  std::string famFile = DATA_MODULE_TEST_DIR "/data/bedbimfam/real_example.fam";

  auto bedMatrix = BedMatrixType::createFromBedBimFam(bedFile, bimFile, famFile);

  // Test getting basic information
  {
    CHECK(bedMatrix.getData().rows() == static_cast<index_t>(50l));
    CHECK(bedMatrix.getData().cols() == static_cast<index_t>(100l));
    CHECK(bedMatrix.getNumIndividuals() == 50ul);
    CHECK(bedMatrix.getNumSites() == 100ul);

    const auto& physicalPositions = bedMatrix.getPhysicalPositions();
    CHECK(physicalPositions.size() == 100ul);
    for (unsigned long i = 0ul; i < physicalPositions.size(); ++i) {
      CHECK(physicalPositions.at(i) == i + 1ul);
    }

    const auto& geneticPositions = bedMatrix.getGeneticPositions();
    CHECK(geneticPositions.size() == 100ul);
    for (auto genPos : geneticPositions) {
      CHECK(genPos == 0.0);
    }

    const auto& siteNames = bedMatrix.getSiteNames();
    CHECK(siteNames.size() == 100ul);
    CHECK(siteNames.at(67ul) == "null_67");
  }

  // Test getting slices
  {
    cvec_ul_t site = bedMatrix.getSite(0ul).cast<unsigned long>();
    CHECK(site.size() == static_cast<index_t>(50l));
    CHECK(site(0) == 2ul);
    CHECK(site(41) == 3ul);
    CHECK(site(42) == 2ul);
    CHECK(site(43) == 1ul);
    CHECK(site(44) == 2ul);

    cvec_ul_t ind = bedMatrix.getIndividual(2ul).cast<unsigned long>();
    CHECK(ind.size() == static_cast<index_t>(100l));
    CHECK(ind(0) == 1ul);
    CHECK(ind(1) == 2ul);
    CHECK(ind(2) == 2ul);
    CHECK(ind(3) == 2ul);
    CHECK(ind(4) == 2ul);
    CHECK(ind(23) == 3ul);
  }

  // Test counts of missing data
  {
    rvec_ul_t missing = bedMatrix.getMissingCounts();
    CHECK(missing.size() == static_cast<index_t>(100l));
    CHECK(missing(0) == 1ul);
    CHECK(missing(1) == 1ul);
    CHECK(missing(2) == 3ul);
    CHECK(missing(3) == 2ul);
    for (unsigned long i = 0; i < bedMatrix.getNumSites(); ++i) {
      CHECK(bedMatrix.getMissingCount(i) == missing(static_cast<index_t>(i)));
    }

    rvec_dbl_t missing_frequencies = bedMatrix.getMissingFrequencies();
    CHECK(missing_frequencies.size() == static_cast<index_t>(100l));
    CHECK(missing_frequencies(0) == Approx(1.0 / 50.0));
    CHECK(missing_frequencies(1) == Approx(1.0 / 50.0));
    CHECK(missing_frequencies(2) == Approx(3.0 / 50.0));
    CHECK(missing_frequencies(3) == Approx(2.0 / 50.0));
    for (unsigned long i = 0; i < bedMatrix.getNumSites(); ++i) {
      CHECK(bedMatrix.getMissingFrequency(i) == Approx(missing_frequencies(static_cast<index_t>(i))));
    }
  }

  // Test allele counts
  {
    rvec_ul_t derivedAlleleCounts = bedMatrix.getDerivedAlleleCounts();
    CHECK(derivedAlleleCounts.size() == static_cast<index_t>(100l));
    CHECK(derivedAlleleCounts(0) == 78ul);
    CHECK(derivedAlleleCounts(1) == 91ul);
    CHECK(derivedAlleleCounts(2) == 70ul);
    CHECK(derivedAlleleCounts(3) == 72ul);
    for (unsigned long i = 0; i < bedMatrix.getNumSites(); ++i) {
      CHECK(bedMatrix.getDerivedAlleleCount(i) == derivedAlleleCounts(static_cast<index_t>(i)));
    }

    rvec_ul_t minorAlleleCounts = bedMatrix.getMinorAlleleCounts();
    CHECK(minorAlleleCounts.size() == static_cast<index_t>(100l));
    CHECK(minorAlleleCounts(0) == 20ul);
    CHECK(minorAlleleCounts(1) == 7ul);
    CHECK(minorAlleleCounts(2) == 24ul);
    CHECK(minorAlleleCounts(3) == 24ul);
    for (unsigned long i = 0; i < bedMatrix.getNumSites(); ++i) {
      CHECK(bedMatrix.getMinorAlleleCount(i) == minorAlleleCounts(static_cast<index_t>(i)));
    }
  }

  // Test allele frequencies
  {
    rvec_dbl_t derivedAlleleFrequencies = bedMatrix.getDerivedAlleleFrequencies();
    CHECK(derivedAlleleFrequencies.size() == static_cast<index_t>(100l));
    CHECK(derivedAlleleFrequencies(0) == Approx(0.795918345451355));
    CHECK(derivedAlleleFrequencies(1) == Approx(0.9285714030265808));
    CHECK(derivedAlleleFrequencies(2) == Approx(0.7446808218955994));
    for (unsigned long i = 0; i < bedMatrix.getNumSites(); ++i) {
      CHECK(bedMatrix.getDerivedAlleleFrequency(i) == derivedAlleleFrequencies(static_cast<index_t>(i)));
    }
  }

  // Test allele frequencies
  {
    rvec_dbl_t minorAlleleFrequencies = bedMatrix.getMinorAlleleFrequencies();
    CHECK(minorAlleleFrequencies.size() == static_cast<index_t>(100l));
    CHECK(minorAlleleFrequencies(0) == Approx(1.0 - 0.795918345451355));
    CHECK(minorAlleleFrequencies(1) == Approx(1.0 - 0.9285714030265808));
    CHECK(minorAlleleFrequencies(2) == Approx(1.0 - 0.7446808218955994));
    for (unsigned long i = 0; i < bedMatrix.getNumSites(); ++i) {
      CHECK(bedMatrix.getMinorAlleleFrequency(i) == minorAlleleFrequencies(static_cast<index_t>(i)));
    }
  }
}

} // namespace asmc
